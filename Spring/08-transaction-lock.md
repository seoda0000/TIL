# 트랜잭션과 락

## 1. 트랜잭션과 격리 수준

### ACID

- 원자성: 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공하든가 모두 실패해야 한다.
- 일관성 : 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다. 예를 들어 데이터베이스에서 정한 무결성 제약 조건을 항상 만족해야 한다.
- 격리성 : 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다.
- 지속성 : 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다. 중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다.

트랜잭션은 원자성, 일관성, 지속성을 보장한다.

격리성을 완벽하게 보장하려면 트랜잭션을 차례대로 실행해야 한다 → 성능 문제 발생. 격리 수준을 선택해야 한다.

### 트랜잭션 격리 수준

`격리 수준이 낮다` : 동시성 증가, 문제 발생

- READ UNCOMMITED 커밋되지 않은 읽기
- READ COMMITED 커밋된 읽기
- REPEATABLE READ 반복 가능한 읽기
- SERIALIZABLE 직렬화 가능

`격리 수준이 높다`

### 격리 수준에 따른 문제점

| 격리 수준       | DIRTY READ | NON-REPEATABLE READ | PHANTOM READ |
| --------------- | ---------- | ------------------- | ------------ |
| READ UNCOMMITED | o          | o                   | o            |
| READ COMMITED   |            | o                   | o            |
| REPEATABLE READ |            |                     | o            |
| SERIALIZABLE    |            |                     |              |

- DIRTY READ : 트랜잭션 1이 커밋하지 않아도 트랜잭션 1이 수정중인 데이터를 트랜잭션 2가 볼 수 있다. 이때 트랜잭션2가 해당 데이터를 사용하는데 트랜잭션1이 롤백하면 정합성에 심각한 문제가 생긴다.
- NON-REPEATABLE READ : 반복해서 같은 데이터를 읽을 수 없는 상태. 트랜잭션 1이 데이터 A를 조회 중인데 트랜잭션 2가 데이터 A를 수정하고 커밋하면, 트랜잭션1이 다시 데이터 A를 조회했을 때 수정된 데이터가 조회된다.
- PHANTOM READ : 반복 조회 시 결과 집합이 달라지는 상태. 트랜잭션 1이 10살 이하 회원을 조회했는데 트랜잭션 2가 5살 회원을 추가하고 커밋하면, 트랜잭션 1이 다시 10살 이하 회원을 조회했을 때 회원 하나가 추가된다.
- SERIALIZABLE : 가장 엄격한 트랜잭션 격리 수준. 동시성 처리 성능익 급격히 떨어질 수 있다.

- 보통 READ COMMITTED 격리 수준을 기본으로 사용
- 최근에는 락보다는 MVCC를 사용한다.

## 2. 낙관적 락과 비관적 락 기초

JPA 영속성 컨텍스트(1차 캐시)를 적절히 활용(엔티티로 조회)

→ READ COMMITTED 격리 수준이어도 애플리케이션 레벨에서 REPEATABLE READ가 가능

### 낙관적 락

- 트랜잭션 대부분은 충돌이 발생하지 않는다고 낙관적으로 가정.
- JPA가 제공하는 버전 관리 기능을 사용
- 애플리케이션이 제공하는 락
- 트랜잭션을 커밋하기 전까지는 트랜잭션의 충돌을 알 수 없다.

### 비관적 락

- 트랜잭션의 충돌이 발생한다고 가정하고 우선 락을 건다.
- 데이터베이스가 제공하는 락 기능 사용.
- ex) `select for update`

### 두 번의 갱신 분실 문제

- 사용자 A가 공지사항을 수정하고, 사용자 B가 공지사항을 수정했을 때 B의 수정사항만 남게 되었을 때
- 데이터베이스 트랜잭션의 범위를 넘어선 문제

<aside>
💡 마지막 커밋만 인정하기

사용자 A의 내용은 무시, 사용자 B의 내용만 인정

</aside>

<aside>
💡 최초 커밋만 인정하기

사용자 A가 수정을 완료했으므로 사용자 B가 수정을 완료할 때 오류 발생

</aside>

<aside>
💡 충돌하는 갱신 내용 병합하기 (기본)

사용자 A와 사용자 B의 수정사항을 병합

</aside>

## 3. @Version

- JPA에 버전 관리 기능 추가
- 적용 가능한 타입 : `Long`, `Integer`, `Short`, `Timestamp`

```java
@Entity
public class Board {
	@Id
	private String id;
	private String title;

	@Version
	private Integer version; // 버전 관리용 필드
}
```

- 엔티티를 수정할 때마다 버전이 하나씩 자동으로 증가
- 엔티티를 수정할 때 조회 시점과 수정 시점의 버전이 다르면 예외 발생
- `💡 최초 커밋만 인정하기` 적용

### JPA의 버전 정보 비교 방법

엔티티를 수정하고 트랜잭션을 커밋

영속성 컨텍스트를 플러시 → **엔티티의 버전 정보를 검색 조건에 추가**하고 UPDATE 쿼리 실행

```sql
UPDATE BOARD
SET
		TITLE=?,
		VERSION=? (버전 + 1 증가)
WHERE
		ID=?
		AND VERSION=? (버전 비교)
```

- 값 타입(임베디드 타입, 컬렉션) : 해당 엔티티의 값. 수정하면 엔티티의 버전이 증가
- 연관관계 필드 : 외래 키를 관리하는 주인 필드를 수정할 때만 증가
- 버전 관리 필드는 JPA가 직접 관리하므로 개발자가 임의로 수정하면 안된다.
