칼럼 뒤에 데이터 유형은 꼭 지정되어야 한다.

# 테이블의 불필요한 컬럼 삭제

```sql
ALTER TABLE 테이블명
DROP COLUMN 삭제할 칼럼명
```

# 컬럼 추가

```sql
ALTER TABLE 테이블명
ADD COLUMN 추가할 칼럼명

ALTER TABLE 테이블명
MODIFY COLUMN 추가할 칼럼명
```

# 테이블 이름 변경

```sql
RENAME 테이블명 TO 수정할 테이블명
```

# 테이블 데이터 삭제 + 로그

```sql
DELETE FROM STADIUM
```

# DROP TABLE

테이블 완전히 삭제

# TRUNCATE TABLE

테이블 자체 삭제 XXX

해당 테이블의 모든 행 삭제 (특정 행 선택 불가)

저장 공간이 재사용 가능하도록 해제

| DROP | TRUNCATE | DELETE |
| --- | --- | --- |
| DDL | DDL | DML |
| Rollback 불가능 | Rollback 불가능 | Commit 이전 Rollback 가능 |
| Auto Commit | Auto Commit | 사용자 Commit |
| 테이블이 사용했던 Storage를 모두 Release | 테이블이 사용했던 Storage 중 최초 테이블 생성시 할당된 Storage만 남기고 Release | 데이터를 모두 Delete해도 사용했던 Storage는 Release되지 않음 |
| 테이블의 정의 자체를 완전히 삭제 | 테이블을 최초 생성된 초기상태로 만듬 | 데이터만 삭제 |

# 테이블에 입력된 데이터 조회

```sql
SELECT [ALL/DISTINCT] 보고 싶은 칼럼명, 보고 싶은 칼럼명...
FROM 해당 칼럼들이 있는 테이블명
```

- ALL : 기본값. 중복된 데이터가 있어도 모두 출력
- DISTINCT : 중복된 데이터가 있는 경우 1건으로 처리해서 출력

---

# 데이터베이스 트랜잭션의 4가지 특성

| 특성 | 설명 |
| --- | --- |
| 원자성 | 트랜잭션에서 정의된 연산들은 모두 성공적으로 실행되던지 아니면 전혀 실행되지 않은 상태로 남아있어야 한다. |
| 일관성 | 트랜잭션이 실행되기 전의 데이터베이스 내용이 잘못 되어 있지 않으면 트랜잭션이 실행된 이후에도 데이터베이스 내용에 잘못이 있으면 안된다. |
| 고립성 | 트랜잭션이 실행되는 도중에 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안 된다. |
| 지속성 | 트랜잭션이 성공적으로 수행되면 그 트랜잭션이 갱신한 데이터베이스의 내용은 영구적으로 저장된다. |

## 트랜잭션에 대한 격리성이 낮은 경우 발생할 수 있는 문제점

- Dirty Read : 다른 트랜잭션에 의해 수행되었지만 아직 커밋되지 않은 데이터를 읽는 것
- Non-Repeatable Read : 한 트랜잭션 내에서 같은 쿼리를 두번 수행했는데, 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제하는 바람에 두 쿼리 결과가 다르게 나타나는 현상
- Phantom Read : 한 트랜잭션 내에서 같은 쿼리를 두번 수행했는데 첫번째 쿼리에서 없던 유령 레코드가 두번째 쿼리에서 나타나는 현상

## 논리연산자 우선순위

NOT > AND > OR

ORACLE : ‘’ === NULL

SQL Server : ‘ ’ ≠ NULL

# 단일행 NULL 관련 함수

| 일반형 함수 | 함수 설명 |
| --- | --- |
| NVL(표현식1, 표현식2) / ISNULL(표현식1, 표현식2) | 표현식1의 결과값이 NULL이면 표현식2의 값을 출력한다. 단, 표현식1과 표현식2의 결과 데이터 타입이 같아야 한다. NULL 관련 가장 많이 사용되는 함수이므로 상당히 중요하다. |
| NULLIF(표현식1, 표현식2) | 표현식1이 표현식2와 같으면 NULL을, 같지 않으면 표현식1을 리턴한다. |
| COALESCE(표현식1, 표현식2, …) | 임의의 개수 표현식에서 NULL이 아닌 최초의 표현식을 나타낸다. 모든 표현식이 NULL이라면 NULL을 리턴한다. |

# 단일행 문자형 함수

 

| 문자형 함수 | 함수 설명 |
| --- | --- |
| CHR/CHAR(ASCII번호) | ASCII 코드 번호를 문자나 숫자로 바꿔준다 |
| CONCAT(문자열1, 문자열2) | 문자열1과 문자열2를 연결 (||:Oracle, +:SQL) |
| LTRIM(문자열, 지정문자) | 문자열의 첫 문자부터 확인해서 지정 문자가 나타나면 해당 문자를 제거. SQL에서는 공백만 가능 |
| RTRIM(문자열, 지정문자) | 문자열의 마지막 문자부터 확인해서 지정 문자가 나타나면 해당 문자를 제거. SQL에서는 공백만 가능 |
| TRIM([leading|trailing|both] 지정문자 FROM 문자열) | 문자열에서 머리말, 꼬리말, 또는 양쪽에 있는 지정 문자를 제거 (디폴트:both) SQL에서는 공백만 가능 |

# 오라클에서의 날짜 연산

1/24/60 : 1분

1/24/(60/10) : 10분

# NULL 관련 함수

### `NVL(표현식1, 표현식2)`

표현식1의 결과값이 NULL이면 표현식2의 값을 출력

### `ISNULL(표현식1, 표현식2)`

표현식1의 결과값이 NULL이면 표현식2의 값을 출력

### `NULLIF(표현식1, 표현식2)`

표현식1이 표현식2와 같으면 NULL을, 같지 않으면 표현식1을 return

### `COALESCE(표현식1, 표현식2…)`

NULL이 아닌 최초의 표현식을 나타냄

# 집계 함수의 종류

| 집계 함수 | 사용 목적 |
| --- | --- |
| COUNT(*) | NULL값 포함한 행의 수 |
| COUNT(표현식) | 표현식의 값이 NULL값을 제외한 행의 수 |
| SUM([DISTINCT | ALL] 표현식) | 표현식의 NULL값을 제외한 합계 출력 |
| AVG([DISTINCT | ALL] 표현식) | 표현식의 NULL값을 제외한 평균 출력 |
| MAX([DISTINCT | ALL] 표현식) | 표현식의 최대값 출력 |
| MIN([DISTINCT | ALL] 표현식) | 표현식의 최소값 출력 |
| STDDEV([DISTINCT | ALL] 표현식) | 표현식의 표준편차 출력 |
| VARIAN([DISTINCT | ALL] 표현식) | 표현식의 분산 출력 |

# ORDER BY

1. ORDER BY 의 기본 정렬은 오름차순이다
2. SELECT 구문에 사용되지 않은 컬럼도 ORDER BY 구문에서 사용할 수 있다
3. ORDER BY 1, COL1 과 같이 숫자와 컬럼을 혼용하여 사용할 수 있다
4. ORACLE 은 NULL 을 가장 큰 값으로 취급하여 ORDER BY 시 맨 뒤로 정렬되고 SQL SERVER 반대로 가장 앞으로 정렬한다.

# TOP(N)

## TOP(N) WITH TIES

N에 해당하는 값이 여러개일 경우 함께 출력되도록 함

# JOIN

두 개 이상의 테이블들을 연결 또는 결합하여 데이터를 출력

일반적으로 PK, FK의 연관에 의해 성립. 어떤 경우에는 논리적인 값들의 연관만으로 성립.

EQUI Join: 컬럼 값이 정확하게 일치하는 경우. ‘=’만 사용

Non EQUI Join : 이외 비교 연산자. 불가능할 수도 있음.

Like : 해당되는 모든 조건을 출력

# 서브쿼리

ORDER BY 사용 불가

메인 쿼리에서 서브쿼리의 컬럼을 자유롭게 사용할 수 없다. SELECT 사용해야 함.