# 5188. [파이썬 S/W 문제해결 구현] 2일차 - 최소합 D3
https://swexpertacademy.com/main/learn/course/lectureProblemViewer.do

그림처럼 NxN 칸에 숫자가 적힌 판이 주어지고, 각 칸에서는 오른쪽이나 아래로만 이동할 수 있다.

맨 왼쪽 위에서 오른쪽 아래까지 이동할 때, 지나는 칸에 써진 숫자의 합계가 최소가 되도록 움직였다면 이때의 합계가 얼마인지 출력하는 프로그램을 만드시오.

---

### bfs보다 dfs가 빠르다.



* bfs 활용 : 시간 초과

```python
from collections import deque

T = int(input())
for tc in range(1, T + 1):
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]
    q = deque([(0, 0, arr[0][0])])
    mn = 1690
    while q:
        i, j, s = q.popleft()

        if i == N - 1 and j == N - 1:
            if s < mn:
                mn = s
        else:
            for a, b in [(0, 1), (1, 0)]:
                ni, nj = i + a, j + b
                if ni < N and nj < N:
                    if s + arr[ni][nj] < mn:
                        q.append((ni, nj, s + arr[ni][nj]))

    print(f'#{tc}', mn)


```



* dfs 활용 : 통과

```python
import sys
sys.stdin = open('sample_input.txt', 'r')


def dfs(i, j, s):
    global mn
    if i == N - 1 and j == N - 1:
        if s < mn:
            mn = s
            return
    for a, b in [(0, 1), (1, 0)]:
        ni, nj = i + a, j + b
        if ni < N and nj < N:
            if s + arr[ni][nj] < mn:
                dfs(ni, nj, s + arr[ni][nj])
T = int(input())
for tc in range(1, T + 1):
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]
    mn = 1690
    dfs(0, 0, arr[0][0])

    print(f'#{tc}', mn)
```



